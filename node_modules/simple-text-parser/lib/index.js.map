{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["export interface Node {\n  type: string;\n  text: string;\n  [key: string]: unknown;\n}\n\nexport namespace Node {\n  export function is(r: any): r is Node {\n    return r != null && typeof r.type === \"string\" && typeof r.text === \"string\";\n  }\n}\n\nexport type Match = string | RegExp | Match.Location | Match.Location[] | Match.Function;\n\nexport namespace Match {\n  export type Location = [number, number];\n\n  export namespace Location {\n    // eslint-disable-next-line no-shadow\n    export function is(loc: any): loc is Location {\n      return Array.isArray(loc) && loc.length === 2 && typeof loc[0] === \"number\" && typeof loc[1] === \"number\";\n    }\n  }\n\n  export type Function = (str: string) => string | RegExp | Location | Location[];\n\n  export function is(val: any): val is Match {\n    return typeof val === \"string\" || typeof val === \"function\" || isRegExp(val);\n  }\n}\n\nexport type Replace = string | Replace.Function;\n\nexport namespace Replace {\n  export type Function = (match: string, ...groups: string[]) => Partial<Node> | string;\n\n  export function is(val: any): val is Replace {\n    return typeof val === \"string\" || typeof val === \"function\";\n  }\n}\n\nexport interface Rule {\n  match: Match;\n  type?: string;\n  replace?: Replace;\n}\n\nexport namespace Rule {\n  export function is(r: any): r is Rule {\n    return (\n      r != null &&\n      Match.is(r.match) &&\n      (r.type == null || typeof r.type === \"string\") &&\n      (r.replace == null || Replace.is(r.replace)) &&\n      typeof r !== \"string\" // b/c holy cow a string actually fits the rule type\n    );\n  }\n}\n\n// isRegExp adopted from sindresorhus/is-regexp\nfunction isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\n\nexport class Parser {\n  static presets = new Map<string, Match>([\n    [\"tag\", /#[\\S]+/gi],\n    [\n      \"email\",\n      /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/gi,\n    ],\n    [\n      \"url\",\n      /(?:(?:https?):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?/gi,\n    ],\n  ]);\n\n  /**\n   * Register a new global preset rule. Presets don't handle the replacing, only the matching. There are three\n   * pre-included presets: `tag`, `url`, and `email`.\n   */\n  static registerPreset(type: string, match: Match) {\n    if (typeof type !== \"string\" || !type) {\n      throw new TypeError(\"Expecting non-empty string for preset type.\");\n    }\n\n    if (!Match.is(match)) {\n      throw new TypeError(\"Expecting a string, regexp or function for preset match.\");\n    }\n\n    Parser.presets.set(type, match);\n  }\n\n  rules: Rule[] = [];\n\n  /** Add a rule to this parser. A rule consists of a match and optionally, a replace and type. */\n  addRule(match: Match, replace?: Replace, type?: string): this;\n  /** Add a rule object to this parser. */\n  addRule(rule: Rule): this;\n\n  addRule(match: Match | Rule, replace?: Replace, type?: string) {\n    if (Rule.is(match)) {\n      this.rules.push(match);\n      return this;\n    }\n\n    if (!Match.is(match)) {\n      throw new TypeError(\"Expecting string, regex, or function for match.\");\n    }\n\n    if (replace != null && !Replace.is(replace)) {\n      throw new TypeError(\"Expecting string or function for replace.\");\n    }\n\n    this.rules.push({ match, type, replace });\n    return this;\n  }\n\n  /**\n   * Add a registered global preset rule within this parser and give it a replace. The preset must first be registered\n   * using `Parser.registerPreset()` before it can be used with this method.\n   */\n  addPreset(type: string, replace?: Replace) {\n    const match = Parser.presets.get(type);\n    if (!match) throw new Error(`Preset '${type}' hasn't been registered on Parser.`);\n\n    this.rules.push({ match, type, replace });\n    return this;\n  }\n\n  private _replace(str: string, opts: { defaultType?: string; replace?: Replace; groups?: string[] } = {}): Node {\n    const { defaultType = \"text\", replace, groups } = opts;\n\n    let value: Partial<Node> | string;\n    if (typeof replace === \"function\") {\n      value = replace(str, ...(groups || []));\n    } else if (typeof replace === \"string\") {\n      value = replace;\n    } else {\n      value = str;\n    }\n\n    if (typeof value === \"string\") {\n      const node: Node = { type: defaultType, text: value };\n      if (groups) node.groups = groups.slice(0);\n      return node;\n    }\n\n    // in case the user is returning some kind of custom object\n    if (Node.is(value)) return value;\n\n    return { type: defaultType, text: str, ...value };\n  }\n\n  private _toTree(str: string) {\n    const tree: Array<Node | string> = [];\n    if (!str) return tree;\n\n    for (const { match, type: defaultType, replace } of this.rules) {\n      let m = typeof match === \"function\" ? match(str) : match;\n      const opts = { replace, defaultType };\n\n      if (typeof m === \"string\") {\n        if (str.indexOf(m) < 0) continue;\n\n        let si = 0,\n          i;\n        while ((i = str.indexOf(m, si)) > -1) {\n          tree.push(str.substring(si, i));\n          tree.push(this._replace(str.substr(i, m.length), opts));\n          si = i + m.length;\n        }\n\n        tree.push(str.substr(si));\n      } else if (Array.isArray(m)) {\n        if (!m.length) continue;\n        if (Match.Location.is(m)) m = [m];\n\n        let si = 0;\n        for (const loc of m) {\n          if (!Match.Location.is(loc)) continue;\n          const [index, length] = loc;\n\n          if (index < si) break;\n          tree.push(str.substring(si, index));\n          tree.push(this._replace(str.substr(index, length), opts));\n          si = index + length;\n        }\n\n        tree.push(str.substr(si));\n      } else if (isRegExp(m)) {\n        let rmatch = m.exec(str);\n        if (!rmatch) continue;\n\n        let i = 0;\n        while (rmatch != null) {\n          tree.push(str.substring(i, rmatch.index));\n          const substr = str.substr(rmatch.index, rmatch[0].length);\n          tree.push(this._replace(substr, { ...opts, groups: Array.from(rmatch).slice(1) }));\n          i = rmatch.index + rmatch[0].length;\n\n          rmatch = (m.flags || \"\").indexOf(\"g\") >= 0 ? m.exec(str) : null;\n        }\n\n        tree.push(str.substr(i));\n      }\n\n      // only the first matching rule is run\n      break;\n    }\n\n    if (!tree.length) return [{ type: \"text\", text: str }];\n\n    return tree;\n  }\n\n  /**\n   * Returns the parsed string as an array of nodes. Every node includes at least `type` and `text` properties. `type`\n   * defaults to `\"text\"` but could be any value as returned by `replace`. The `text` key is used to replaced the\n   * matched string by `render()`.\n   */\n  toTree(str: string) {\n    const tree = this._toTree(str);\n    const result: Node[] = [];\n\n    for (const val of tree) {\n      if (typeof val === \"string\") {\n        result.push(...this.toTree(val));\n      } else {\n        result.push(val);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a string derived from the text property on a list of nodes.\n   */\n  static renderTree(tree: Node[]) {\n    let result = \"\";\n\n    for (const node of tree) {\n      if (typeof node.text === \"string\") {\n        result += node.text;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a parsed string with all matches replaced.\n   */\n  render(str: string) {\n    return Parser.renderTree(this.toTree(str));\n  }\n}\n\nexport default Parser;\n"]}